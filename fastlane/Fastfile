default_platform('ios')

platform :ios do

  lane :test do
    remote_scan(
      project: "../iosapp/iosapp.xcodeproj",
      devices: ["iPhone 5s"]
    )
  end

  def upload_app(app_path)
    # calculate checksum of app
    checksum = Zlib::crc32(Dir.glob("#{app_path}/**/*").map { |name| [name, File.mtime(name)] }.to_s)

    # archive app
    archive = "../#{checksum}.zip"
    if(!File.exist?(archive)) 
      zf = ZipFileGenerator.new("../iosapp", archive)
      zf.write()
    end

    # upload archive
    upload_id = upload_file(archive)
    # TODO skip additional upload if file was uploaded before 
    # (assumption: if archive already existed, it was also uploaded: check via new API if true)  end
  end

  def trigger_remote_action(action, upload_id)
    url = "http://remote-fastlane.betamo.de/trigger_build.php?upload_id=#{upload_id}"
    # TODO use action to define different actions to trigger
    created_request = download(url: url)
    # TODO handle eventual errors
    created_request['request']['id']
  end

  def retrieve_build(repository, request_id)
    require 'travis/client'
    Travis.connect
    repo = Travis::Repository.find(slug: repository)
    requests = repo.requests
    request = extract_request(requests, request_id);
    builds = request.builds
    build = builds.first
  end

  lane :remote_scan do |options|
    # upload app
    APP_PATH = '../iosapp' # TODO
    upload_id = upload_app(APP_PATH)

    # trigger build for upload
    request_id = trigger_remote_action('scan', upload_id)

    # poll request/build status

    REPOSITORY = 'janpio/fastlane-runner'
    build_id = retrieve_build(REPOSITORY, request_id)
  
    loop do
      puts "# builds2 ###"
      build2 = Travis::Build.find(id: build.id)
      puts build2
      puts build2.id
      puts build2.state

      # exit when NOT created or started
      # exit when 'passed'
      # :created, :received, :started, :passed, :failed, :errored, :canceled
      if(build2.state != 'created' && build2.state != 'received' && build2.state != 'started')
        output_log(build2)
        break
      end

      sleep(3)
    end

    #output result
  end
  
  def extract_request(requests, request_id)
    puts "# extract ###"
    requests.each do |request|
      return request if request.id == request_id
    end
    return nil
  end

  def upload_file(filename)
    require 'net/http/post/multipart'

    url = URI.parse('http://remote-fastlane.betamo.de/upload.php')
    File.open(filename) do |file|
      req = Net::HTTP::Post::Multipart.new url.path,
        "datei" => UploadIO.new(file, "application/zip", filename)
      res = Net::HTTP.start(url.host, url.port) do |http|
        return http.request(req).body
      end
    end
  end

  lane :log do
    build_id = '465746250'

    require 'travis/client'
    Travis.connect
    build2 = Travis::Build.find(id: build_id)
    output_log(build2)
  end

  def output_log(build2)
    #puts build2.methods.sort
    log = build2.jobs.first.log
    puts log

    logtext = log.content

    # extract relevant log
    relevant_log = ''
    keep = false
    start_line = /Cruising over to lane 'test'/
    end_line = /Cruising back to lane 'remote_scan'/
    logtext.each_line do |line|
      keep = false if line =~ end_line
      relevant_log = relevant_log + line if keep == true
      keep = true if line =~ start_line
      # TODO remove travis stuff
    end
    puts relevant_log
  end

end

require 'zip'

# This is a simple example which uses rubyzip to
# recursively generate a zip file from the contents of
# a specified directory. The directory itself is not
# included in the archive, rather just its contents.
#
# Usage:
#   directoryToZip = "/tmp/input"
#   outputFile = "/tmp/out.zip"
#   zf = ZipFileGenerator.new(directoryToZip, outputFile)
#   zf.write()
class ZipFileGenerator

# Initialize with the directory to zip and the location of the output archive.
def initialize(inputDir, outputFile)
  @inputDir = inputDir
  @outputFile = outputFile
end

# Zip the input directory.
def write()
  entries = Dir.entries(@inputDir); entries.delete("."); entries.delete("..")
  io = Zip::File.open(@outputFile, Zip::File::CREATE);

  writeEntries(entries, "", io)
  io.close();
end

# A helper method to make the recursion work.
private
def writeEntries(entries, path, io)

  entries.each { |e|
    zipFilePath = path == "" ? e : File.join(path, e)
    diskFilePath = File.join(@inputDir, zipFilePath)
    puts "Deflating " + diskFilePath
    if  File.directory?(diskFilePath)
      io.mkdir(zipFilePath)
      subdir =Dir.entries(diskFilePath); subdir.delete("."); subdir.delete("..")
      writeEntries(subdir, zipFilePath, io)
    else
      io.get_output_stream(zipFilePath) { |f| f.puts(File.open(diskFilePath, "rb").read())}
    end
  }
end

end