default_platform('ios')

platform :ios do

  lane :test do
    remote_scan(
      project: "../iosapp/iosapp.xcodeproj",
      devices: ["iPhone 5s"]
    )
  end

  lane :remote_scan do |options|
    APP_PATH = '../iosapp' # TODO    
    REPOSITORY = 'janpio/fastlane-runner'

    # upload app
    upload_id = upload_app(APP_PATH)
    puts "app uploaded"

    # trigger build for upload
    request_id = trigger_remote_action('scan', upload_id)
    puts "remote action triggered"

    # poll request/build status
    spinner = TTY::Spinner.new("[:spinner] Waiting for remote action to finish...", format: :dots)
    spinner.auto_spin
    build = retrieve_build(REPOSITORY, request_id)
    log = wait_and_retrieve_log(build)
    spinner.success("Done")

    # output log
    output_log(log)
  end

  def upload_app(app_path)
    # calculate checksum of app
    checksum = Zlib::crc32(Dir.glob("#{app_path}/**/*").map { |name| [name, File.mtime(name)] }.to_s)

    # archive app
    archive = "../#{checksum}.zip"
    if(!File.exist?(archive)) 
      zf = ZipFileGenerator.new("../iosapp", archive)
      zf.write()
    end

    # upload archive
    upload_id = upload_file(archive)
    # TODO skip additional upload if file was uploaded before 
    # (assumption: if archive already existed, it was also uploaded: check via new API if true)  end
  end

  def upload_file(filename)
    require 'net/http/post/multipart'

    url = URI.parse('http://remote-fastlane.betamo.de/upload.php')
    File.open(filename) do |file|
      req = Net::HTTP::Post::Multipart.new url.path,
        "datei" => UploadIO.new(file, "application/zip", filename)
      res = Net::HTTP.start(url.host, url.port) do |http|
        return http.request(req).body
      end
    end
  end

  def trigger_remote_action(action, upload_id)
    url = "http://remote-fastlane.betamo.de/trigger_build.php?upload_id=#{upload_id}"
    # TODO use action to define different actions to trigger
    created_request = download(url: url)
    # TODO handle eventual errors
    created_request['request']['id']
  end

  def retrieve_build(repository, request_id)
    require 'travis/client'
    Travis.connect
    repo = Travis::Repository.find(slug: repository)
    requests = repo.requests
    request = extract_request(requests, request_id);
    builds = request.builds
    build = builds.first
  end

  def extract_request(requests, request_id)
    requests.each do |request|
      return request if request.id == request_id
    end
    return nil
  end

  def wait_and_retrieve_log(build)
    loop do
      build2 = Travis::Build.find(id: build.id)

      # TODO start outputting log as soon as build is started
      
      # wait: :created, :received, :started, 
      # break: :passed, :failed, :errored, :canceled
      processing = (build2.state == 'created' || build2.state == 'received'  || build2.state == 'started')
      return build2 if !processing

      sleep(3)
    end
  end

  lane :log do
    build_id = '465746250'

    require 'travis/client'
    Travis.connect
    build2 = Travis::Build.find(id: build_id)
    output_log(build2)
  end

  def output_log(build2)
    #puts build2.methods.sort
    log = build2.jobs.first.log
    puts log

    logtext = log.content

    # extract relevant log
    relevant_log = ''
    keep = false
    start_line = /Cruising over to lane 'test'/
    end_line = /Cruising back to lane 'remote_scan'/
    logtext.each_line do |line|
      keep = false if line =~ end_line
      relevant_log = relevant_log + line if keep == true
      keep = true if line =~ start_line
      # TODO remove travis stuff
    end
    puts relevant_log
  end

end

require 'zip'

# This is a simple example which uses rubyzip to
# recursively generate a zip file from the contents of
# a specified directory. The directory itself is not
# included in the archive, rather just its contents.
#
# Usage:
#   directoryToZip = "/tmp/input"
#   outputFile = "/tmp/out.zip"
#   zf = ZipFileGenerator.new(directoryToZip, outputFile)
#   zf.write()
class ZipFileGenerator

# Initialize with the directory to zip and the location of the output archive.
def initialize(inputDir, outputFile)
  @inputDir = inputDir
  @outputFile = outputFile
end

# Zip the input directory.
def write()
  entries = Dir.entries(@inputDir); entries.delete("."); entries.delete("..")
  io = Zip::File.open(@outputFile, Zip::File::CREATE);

  writeEntries(entries, "", io)
  io.close();
end

# A helper method to make the recursion work.
private
def writeEntries(entries, path, io)

  entries.each { |e|
    zipFilePath = path == "" ? e : File.join(path, e)
    diskFilePath = File.join(@inputDir, zipFilePath)
    puts "Deflating " + diskFilePath
    if  File.directory?(diskFilePath)
      io.mkdir(zipFilePath)
      subdir =Dir.entries(diskFilePath); subdir.delete("."); subdir.delete("..")
      writeEntries(subdir, zipFilePath, io)
    else
      io.get_output_stream(zipFilePath) { |f| f.puts(File.open(diskFilePath, "rb").read())}
    end
  }
end

end